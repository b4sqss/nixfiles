diff -crNb dmenu-5.0/.git/HEAD Projects/git/dmenu/.git/HEAD
*** dmenu-5.0/.git/HEAD	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/HEAD	2021-11-27 12:52:26.792815140 -0300
***************
*** 0 ****
--- 1 ----
+ ref: refs/heads/master
diff -crNb dmenu-5.0/.git/config Projects/git/dmenu/.git/config
*** dmenu-5.0/.git/config	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/config	2021-11-27 12:52:26.793815141 -0300
***************
*** 0 ****
--- 1,11 ----
+ [core]
+ 	repositoryformatversion = 0
+ 	filemode = true
+ 	bare = false
+ 	logallrefupdates = true
+ [remote "origin"]
+ 	url = https://github.com/NotCreative21/dmenu.git
+ 	fetch = +refs/heads/*:refs/remotes/origin/*
+ [branch "master"]
+ 	remote = origin
+ 	merge = refs/heads/master
diff -crNb dmenu-5.0/.git/description Projects/git/dmenu/.git/description
*** dmenu-5.0/.git/description	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/description	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1 ----
+ Unnamed repository; edit this file 'description' to name the repository.
diff -crNb dmenu-5.0/.git/hooks/applypatch-msg.sample Projects/git/dmenu/.git/hooks/applypatch-msg.sample
*** dmenu-5.0/.git/hooks/applypatch-msg.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/applypatch-msg.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,15 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to check the commit log message taken by
+ # applypatch from an e-mail message.
+ #
+ # The hook should exit with non-zero status after issuing an
+ # appropriate message if it wants to stop the commit.  The hook is
+ # allowed to edit the commit message file.
+ #
+ # To enable this hook, rename this file to "applypatch-msg".
+ 
+ . git-sh-setup
+ commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+ test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+ :
diff -crNb dmenu-5.0/.git/hooks/commit-msg.sample Projects/git/dmenu/.git/hooks/commit-msg.sample
*** dmenu-5.0/.git/hooks/commit-msg.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/commit-msg.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,24 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to check the commit log message.
+ # Called by "git commit" with one argument, the name of the file
+ # that has the commit message.  The hook should exit with non-zero
+ # status after issuing an appropriate message if it wants to stop the
+ # commit.  The hook is allowed to edit the commit message file.
+ #
+ # To enable this hook, rename this file to "commit-msg".
+ 
+ # Uncomment the below to add a Signed-off-by line to the message.
+ # Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+ # hook is more suited to it.
+ #
+ # SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+ # grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+ 
+ # This example catches duplicate Signed-off-by lines.
+ 
+ test "" = "$(grep '^Signed-off-by: ' "$1" |
+ 	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+ 	echo >&2 Duplicate Signed-off-by lines.
+ 	exit 1
+ }
diff -crNb dmenu-5.0/.git/hooks/fsmonitor-watchman.sample Projects/git/dmenu/.git/hooks/fsmonitor-watchman.sample
*** dmenu-5.0/.git/hooks/fsmonitor-watchman.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/fsmonitor-watchman.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,173 ----
+ #!/nix/store/4b6ihwd90vqzjaz47f2h6fzjhzsvhgzb-perl-5.34.0/bin/perl
+ 
+ use strict;
+ use warnings;
+ use IPC::Open2;
+ 
+ # An example hook script to integrate Watchman
+ # (https://facebook.github.io/watchman/) with git to speed up detecting
+ # new and modified files.
+ #
+ # The hook is passed a version (currently 2) and last update token
+ # formatted as a string and outputs to stdout a new update token and
+ # all files that have been modified since the update token. Paths must
+ # be relative to the root of the working tree and separated by a single NUL.
+ #
+ # To enable this hook, rename this file to "query-watchman" and set
+ # 'git config core.fsmonitor .git/hooks/query-watchman'
+ #
+ my ($version, $last_update_token) = @ARGV;
+ 
+ # Uncomment for debugging
+ # print STDERR "$0 $version $last_update_token\n";
+ 
+ # Check the hook interface version
+ if ($version ne 2) {
+ 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+ 	    "Falling back to scanning...\n";
+ }
+ 
+ my $git_work_tree = get_working_dir();
+ 
+ my $retry = 1;
+ 
+ my $json_pkg;
+ eval {
+ 	require JSON::XS;
+ 	$json_pkg = "JSON::XS";
+ 	1;
+ } or do {
+ 	require JSON::PP;
+ 	$json_pkg = "JSON::PP";
+ };
+ 
+ launch_watchman();
+ 
+ sub launch_watchman {
+ 	my $o = watchman_query();
+ 	if (is_work_tree_watched($o)) {
+ 		output_result($o->{clock}, @{$o->{files}});
+ 	}
+ }
+ 
+ sub output_result {
+ 	my ($clockid, @files) = @_;
+ 
+ 	# Uncomment for debugging watchman output
+ 	# open (my $fh, ">", ".git/watchman-output.out");
+ 	# binmode $fh, ":utf8";
+ 	# print $fh "$clockid\n@files\n";
+ 	# close $fh;
+ 
+ 	binmode STDOUT, ":utf8";
+ 	print $clockid;
+ 	print "\0";
+ 	local $, = "\0";
+ 	print @files;
+ }
+ 
+ sub watchman_clock {
+ 	my $response = qx/watchman clock "$git_work_tree"/;
+ 	die "Failed to get clock id on '$git_work_tree'.\n" .
+ 		"Falling back to scanning...\n" if $? != 0;
+ 
+ 	return $json_pkg->new->utf8->decode($response);
+ }
+ 
+ sub watchman_query {
+ 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+ 	or die "open2() failed: $!\n" .
+ 	"Falling back to scanning...\n";
+ 
+ 	# In the query expression below we're asking for names of files that
+ 	# changed since $last_update_token but not from the .git folder.
+ 	#
+ 	# To accomplish this, we're using the "since" generator to use the
+ 	# recency index to select candidate nodes and "fields" to limit the
+ 	# output to file names only. Then we're using the "expression" term to
+ 	# further constrain the results.
+ 	if (substr($last_update_token, 0, 1) eq "c") {
+ 		$last_update_token = "\"$last_update_token\"";
+ 	}
+ 	my $query = <<"	END";
+ 		["query", "$git_work_tree", {
+ 			"since": $last_update_token,
+ 			"fields": ["name"],
+ 			"expression": ["not", ["dirname", ".git"]]
+ 		}]
+ 	END
+ 
+ 	# Uncomment for debugging the watchman query
+ 	# open (my $fh, ">", ".git/watchman-query.json");
+ 	# print $fh $query;
+ 	# close $fh;
+ 
+ 	print CHLD_IN $query;
+ 	close CHLD_IN;
+ 	my $response = do {local $/; <CHLD_OUT>};
+ 
+ 	# Uncomment for debugging the watch response
+ 	# open ($fh, ">", ".git/watchman-response.json");
+ 	# print $fh $response;
+ 	# close $fh;
+ 
+ 	die "Watchman: command returned no output.\n" .
+ 	"Falling back to scanning...\n" if $response eq "";
+ 	die "Watchman: command returned invalid output: $response\n" .
+ 	"Falling back to scanning...\n" unless $response =~ /^\{/;
+ 
+ 	return $json_pkg->new->utf8->decode($response);
+ }
+ 
+ sub is_work_tree_watched {
+ 	my ($output) = @_;
+ 	my $error = $output->{error};
+ 	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+ 		$retry--;
+ 		my $response = qx/watchman watch "$git_work_tree"/;
+ 		die "Failed to make watchman watch '$git_work_tree'.\n" .
+ 		    "Falling back to scanning...\n" if $? != 0;
+ 		$output = $json_pkg->new->utf8->decode($response);
+ 		$error = $output->{error};
+ 		die "Watchman: $error.\n" .
+ 		"Falling back to scanning...\n" if $error;
+ 
+ 		# Uncomment for debugging watchman output
+ 		# open (my $fh, ">", ".git/watchman-output.out");
+ 		# close $fh;
+ 
+ 		# Watchman will always return all files on the first query so
+ 		# return the fast "everything is dirty" flag to git and do the
+ 		# Watchman query just to get it over with now so we won't pay
+ 		# the cost in git to look up each individual file.
+ 		my $o = watchman_clock();
+ 		$error = $output->{error};
+ 
+ 		die "Watchman: $error.\n" .
+ 		"Falling back to scanning...\n" if $error;
+ 
+ 		output_result($o->{clock}, ("/"));
+ 		$last_update_token = $o->{clock};
+ 
+ 		eval { launch_watchman() };
+ 		return 0;
+ 	}
+ 
+ 	die "Watchman: $error.\n" .
+ 	"Falling back to scanning...\n" if $error;
+ 
+ 	return 1;
+ }
+ 
+ sub get_working_dir {
+ 	my $working_dir;
+ 	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+ 		$working_dir = Win32::GetCwd();
+ 		$working_dir =~ tr/\\/\//;
+ 	} else {
+ 		require Cwd;
+ 		$working_dir = Cwd::cwd();
+ 	}
+ 
+ 	return $working_dir;
+ }
diff -crNb dmenu-5.0/.git/hooks/post-update.sample Projects/git/dmenu/.git/hooks/post-update.sample
*** dmenu-5.0/.git/hooks/post-update.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/post-update.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,8 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to prepare a packed repository for use over
+ # dumb transports.
+ #
+ # To enable this hook, rename this file to "post-update".
+ 
+ exec git update-server-info
diff -crNb dmenu-5.0/.git/hooks/pre-applypatch.sample Projects/git/dmenu/.git/hooks/pre-applypatch.sample
*** dmenu-5.0/.git/hooks/pre-applypatch.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/pre-applypatch.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,14 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to verify what is about to be committed
+ # by applypatch from an e-mail message.
+ #
+ # The hook should exit with non-zero status after issuing an
+ # appropriate message if it wants to stop the commit.
+ #
+ # To enable this hook, rename this file to "pre-applypatch".
+ 
+ . git-sh-setup
+ precommit="$(git rev-parse --git-path hooks/pre-commit)"
+ test -x "$precommit" && exec "$precommit" ${1+"$@"}
+ :
diff -crNb dmenu-5.0/.git/hooks/pre-commit.sample Projects/git/dmenu/.git/hooks/pre-commit.sample
*** dmenu-5.0/.git/hooks/pre-commit.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/pre-commit.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,49 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to verify what is about to be committed.
+ # Called by "git commit" with no arguments.  The hook should
+ # exit with non-zero status after issuing an appropriate message if
+ # it wants to stop the commit.
+ #
+ # To enable this hook, rename this file to "pre-commit".
+ 
+ if git rev-parse --verify HEAD >/dev/null 2>&1
+ then
+ 	against=HEAD
+ else
+ 	# Initial commit: diff against an empty tree object
+ 	against=$(git hash-object -t tree /dev/null)
+ fi
+ 
+ # If you want to allow non-ASCII filenames set this variable to true.
+ allownonascii=$(git config --type=bool hooks.allownonascii)
+ 
+ # Redirect output to stderr.
+ exec 1>&2
+ 
+ # Cross platform projects tend to avoid non-ASCII filenames; prevent
+ # them from being added to the repository. We exploit the fact that the
+ # printable range starts at the space character and ends with tilde.
+ if [ "$allownonascii" != "true" ] &&
+ 	# Note that the use of brackets around a tr range is ok here, (it's
+ 	# even required, for portability to Solaris 10's /usr/bin/tr), since
+ 	# the square bracket bytes happen to fall in the designated range.
+ 	test $(git diff --cached --name-only --diff-filter=A -z $against |
+ 	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+ then
+ 	cat <<\EOF
+ Error: Attempt to add a non-ASCII file name.
+ 
+ This can cause problems if you want to work with people on other platforms.
+ 
+ To be portable it is advisable to rename the file.
+ 
+ If you know what you are doing you can disable this check using:
+ 
+   git config hooks.allownonascii true
+ EOF
+ 	exit 1
+ fi
+ 
+ # If there are whitespace errors, print the offending file names and fail.
+ exec git diff-index --check --cached $against --
diff -crNb dmenu-5.0/.git/hooks/pre-merge-commit.sample Projects/git/dmenu/.git/hooks/pre-merge-commit.sample
*** dmenu-5.0/.git/hooks/pre-merge-commit.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/pre-merge-commit.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,13 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to verify what is about to be committed.
+ # Called by "git merge" with no arguments.  The hook should
+ # exit with non-zero status after issuing an appropriate message to
+ # stderr if it wants to stop the merge commit.
+ #
+ # To enable this hook, rename this file to "pre-merge-commit".
+ 
+ . git-sh-setup
+ test -x "$GIT_DIR/hooks/pre-commit" &&
+         exec "$GIT_DIR/hooks/pre-commit"
+ :
diff -crNb dmenu-5.0/.git/hooks/pre-push.sample Projects/git/dmenu/.git/hooks/pre-push.sample
*** dmenu-5.0/.git/hooks/pre-push.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/pre-push.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,53 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ 
+ # An example hook script to verify what is about to be pushed.  Called by "git
+ # push" after it has checked the remote status, but before anything has been
+ # pushed.  If this script exits with a non-zero status nothing will be pushed.
+ #
+ # This hook is called with the following parameters:
+ #
+ # $1 -- Name of the remote to which the push is being done
+ # $2 -- URL to which the push is being done
+ #
+ # If pushing without using a named remote those arguments will be equal.
+ #
+ # Information about the commits which are being pushed is supplied as lines to
+ # the standard input in the form:
+ #
+ #   <local ref> <local oid> <remote ref> <remote oid>
+ #
+ # This sample shows how to prevent push of commits where the log message starts
+ # with "WIP" (work in progress).
+ 
+ remote="$1"
+ url="$2"
+ 
+ zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+ 
+ while read local_ref local_oid remote_ref remote_oid
+ do
+ 	if test "$local_oid" = "$zero"
+ 	then
+ 		# Handle delete
+ 		:
+ 	else
+ 		if test "$remote_oid" = "$zero"
+ 		then
+ 			# New branch, examine all commits
+ 			range="$local_oid"
+ 		else
+ 			# Update to existing branch, examine new commits
+ 			range="$remote_oid..$local_oid"
+ 		fi
+ 
+ 		# Check for WIP commit
+ 		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+ 		if test -n "$commit"
+ 		then
+ 			echo >&2 "Found WIP commit in $local_ref, not pushing"
+ 			exit 1
+ 		fi
+ 	fi
+ done
+ 
+ exit 0
diff -crNb dmenu-5.0/.git/hooks/pre-rebase.sample Projects/git/dmenu/.git/hooks/pre-rebase.sample
*** dmenu-5.0/.git/hooks/pre-rebase.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/pre-rebase.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,169 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # Copyright (c) 2006, 2008 Junio C Hamano
+ #
+ # The "pre-rebase" hook is run just before "git rebase" starts doing
+ # its job, and can prevent the command from running by exiting with
+ # non-zero status.
+ #
+ # The hook is called with the following parameters:
+ #
+ # $1 -- the upstream the series was forked from.
+ # $2 -- the branch being rebased (or empty when rebasing the current branch).
+ #
+ # This sample shows how to prevent topic branches that are already
+ # merged to 'next' branch from getting rebased, because allowing it
+ # would result in rebasing already published history.
+ 
+ publish=next
+ basebranch="$1"
+ if test "$#" = 2
+ then
+ 	topic="refs/heads/$2"
+ else
+ 	topic=`git symbolic-ref HEAD` ||
+ 	exit 0 ;# we do not interrupt rebasing detached HEAD
+ fi
+ 
+ case "$topic" in
+ refs/heads/??/*)
+ 	;;
+ *)
+ 	exit 0 ;# we do not interrupt others.
+ 	;;
+ esac
+ 
+ # Now we are dealing with a topic branch being rebased
+ # on top of master.  Is it OK to rebase it?
+ 
+ # Does the topic really exist?
+ git show-ref -q "$topic" || {
+ 	echo >&2 "No such branch $topic"
+ 	exit 1
+ }
+ 
+ # Is topic fully merged to master?
+ not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+ if test -z "$not_in_master"
+ then
+ 	echo >&2 "$topic is fully merged to master; better remove it."
+ 	exit 1 ;# we could allow it, but there is no point.
+ fi
+ 
+ # Is topic ever merged to next?  If so you should not be rebasing it.
+ only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+ only_next_2=`git rev-list ^master           ${publish} | sort`
+ if test "$only_next_1" = "$only_next_2"
+ then
+ 	not_in_topic=`git rev-list "^$topic" master`
+ 	if test -z "$not_in_topic"
+ 	then
+ 		echo >&2 "$topic is already up to date with master"
+ 		exit 1 ;# we could allow it, but there is no point.
+ 	else
+ 		exit 0
+ 	fi
+ else
+ 	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+ 	/nix/store/4b6ihwd90vqzjaz47f2h6fzjhzsvhgzb-perl-5.34.0/bin/perl -e '
+ 		my $topic = $ARGV[0];
+ 		my $msg = "* $topic has commits already merged to public branch:\n";
+ 		my (%not_in_next) = map {
+ 			/^([0-9a-f]+) /;
+ 			($1 => 1);
+ 		} split(/\n/, $ARGV[1]);
+ 		for my $elem (map {
+ 				/^([0-9a-f]+) (.*)$/;
+ 				[$1 => $2];
+ 			} split(/\n/, $ARGV[2])) {
+ 			if (!exists $not_in_next{$elem->[0]}) {
+ 				if ($msg) {
+ 					print STDERR $msg;
+ 					undef $msg;
+ 				}
+ 				print STDERR " $elem->[1]\n";
+ 			}
+ 		}
+ 	' "$topic" "$not_in_next" "$not_in_master"
+ 	exit 1
+ fi
+ 
+ <<\DOC_END
+ 
+ This sample hook safeguards topic branches that have been
+ published from being rewound.
+ 
+ The workflow assumed here is:
+ 
+  * Once a topic branch forks from "master", "master" is never
+    merged into it again (either directly or indirectly).
+ 
+  * Once a topic branch is fully cooked and merged into "master",
+    it is deleted.  If you need to build on top of it to correct
+    earlier mistakes, a new topic branch is created by forking at
+    the tip of the "master".  This is not strictly necessary, but
+    it makes it easier to keep your history simple.
+ 
+  * Whenever you need to test or publish your changes to topic
+    branches, merge them into "next" branch.
+ 
+ The script, being an example, hardcodes the publish branch name
+ to be "next", but it is trivial to make it configurable via
+ $GIT_DIR/config mechanism.
+ 
+ With this workflow, you would want to know:
+ 
+ (1) ... if a topic branch has ever been merged to "next".  Young
+     topic branches can have stupid mistakes you would rather
+     clean up before publishing, and things that have not been
+     merged into other branches can be easily rebased without
+     affecting other people.  But once it is published, you would
+     not want to rewind it.
+ 
+ (2) ... if a topic branch has been fully merged to "master".
+     Then you can delete it.  More importantly, you should not
+     build on top of it -- other people may already want to
+     change things related to the topic as patches against your
+     "master", so if you need further changes, it is better to
+     fork the topic (perhaps with the same name) afresh from the
+     tip of "master".
+ 
+ Let's look at this example:
+ 
+ 		   o---o---o---o---o---o---o---o---o---o "next"
+ 		  /       /           /           /
+ 		 /   a---a---b A     /           /
+ 		/   /               /           /
+ 	       /   /   c---c---c---c B         /
+ 	      /   /   /             \         /
+ 	     /   /   /   b---b C     \       /
+ 	    /   /   /   /             \     /
+     ---o---o---o---o---o---o---o---o---o---o---o "master"
+ 
+ 
+ A, B and C are topic branches.
+ 
+  * A has one fix since it was merged up to "next".
+ 
+  * B has finished.  It has been fully merged up to "master" and "next",
+    and is ready to be deleted.
+ 
+  * C has not merged to "next" at all.
+ 
+ We would want to allow C to be rebased, refuse A, and encourage
+ B to be deleted.
+ 
+ To compute (1):
+ 
+ 	git rev-list ^master ^topic next
+ 	git rev-list ^master        next
+ 
+ 	if these match, topic has not merged in next at all.
+ 
+ To compute (2):
+ 
+ 	git rev-list master..topic
+ 
+ 	if this is empty, it is fully merged to "master".
+ 
+ DOC_END
diff -crNb dmenu-5.0/.git/hooks/pre-receive.sample Projects/git/dmenu/.git/hooks/pre-receive.sample
*** dmenu-5.0/.git/hooks/pre-receive.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/pre-receive.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,24 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to make use of push options.
+ # The example simply echoes all push options that start with 'echoback='
+ # and rejects all pushes when the "reject" push option is used.
+ #
+ # To enable this hook, rename this file to "pre-receive".
+ 
+ if test -n "$GIT_PUSH_OPTION_COUNT"
+ then
+ 	i=0
+ 	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+ 	do
+ 		eval "value=\$GIT_PUSH_OPTION_$i"
+ 		case "$value" in
+ 		echoback=*)
+ 			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+ 			;;
+ 		reject)
+ 			exit 1
+ 		esac
+ 		i=$((i + 1))
+ 	done
+ fi
diff -crNb dmenu-5.0/.git/hooks/prepare-commit-msg.sample Projects/git/dmenu/.git/hooks/prepare-commit-msg.sample
*** dmenu-5.0/.git/hooks/prepare-commit-msg.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/prepare-commit-msg.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,42 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to prepare the commit log message.
+ # Called by "git commit" with the name of the file that has the
+ # commit message, followed by the description of the commit
+ # message's source.  The hook's purpose is to edit the commit
+ # message file.  If the hook fails with a non-zero status,
+ # the commit is aborted.
+ #
+ # To enable this hook, rename this file to "prepare-commit-msg".
+ 
+ # This hook includes three examples. The first one removes the
+ # "# Please enter the commit message..." help message.
+ #
+ # The second includes the output of "git diff --name-status -r"
+ # into the message, just before the "git status" output.  It is
+ # commented because it doesn't cope with --amend or with squashed
+ # commits.
+ #
+ # The third example adds a Signed-off-by line to the message, that can
+ # still be edited.  This is rarely a good idea.
+ 
+ COMMIT_MSG_FILE=$1
+ COMMIT_SOURCE=$2
+ SHA1=$3
+ 
+ /nix/store/4b6ihwd90vqzjaz47f2h6fzjhzsvhgzb-perl-5.34.0/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+ 
+ # case "$COMMIT_SOURCE,$SHA1" in
+ #  ,|template,)
+ #    /nix/store/4b6ihwd90vqzjaz47f2h6fzjhzsvhgzb-perl-5.34.0/bin/perl -i.bak -pe '
+ #       print "\n" . `git diff --cached --name-status -r`
+ # 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+ #  *) ;;
+ # esac
+ 
+ # SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+ # git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+ # if test -z "$COMMIT_SOURCE"
+ # then
+ #   /nix/store/4b6ihwd90vqzjaz47f2h6fzjhzsvhgzb-perl-5.34.0/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+ # fi
diff -crNb dmenu-5.0/.git/hooks/push-to-checkout.sample Projects/git/dmenu/.git/hooks/push-to-checkout.sample
*** dmenu-5.0/.git/hooks/push-to-checkout.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/push-to-checkout.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,78 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ 
+ # An example hook script to update a checked-out tree on a git push.
+ #
+ # This hook is invoked by git-receive-pack(1) when it reacts to git
+ # push and updates reference(s) in its repository, and when the push
+ # tries to update the branch that is currently checked out and the
+ # receive.denyCurrentBranch configuration variable is set to
+ # updateInstead.
+ #
+ # By default, such a push is refused if the working tree and the index
+ # of the remote repository has any difference from the currently
+ # checked out commit; when both the working tree and the index match
+ # the current commit, they are updated to match the newly pushed tip
+ # of the branch. This hook is to be used to override the default
+ # behaviour; however the code below reimplements the default behaviour
+ # as a starting point for convenient modification.
+ #
+ # The hook receives the commit with which the tip of the current
+ # branch is going to be updated:
+ commit=$1
+ 
+ # It can exit with a non-zero status to refuse the push (when it does
+ # so, it must not modify the index or the working tree).
+ die () {
+ 	echo >&2 "$*"
+ 	exit 1
+ }
+ 
+ # Or it can make any necessary changes to the working tree and to the
+ # index to bring them to the desired state when the tip of the current
+ # branch is updated to the new commit, and exit with a zero status.
+ #
+ # For example, the hook can simply run git read-tree -u -m HEAD "$1"
+ # in order to emulate git fetch that is run in the reverse direction
+ # with git push, as the two-tree form of git read-tree -u -m is
+ # essentially the same as git switch or git checkout that switches
+ # branches while keeping the local changes in the working tree that do
+ # not interfere with the difference between the branches.
+ 
+ # The below is a more-or-less exact translation to shell of the C code
+ # for the default behaviour for git's push-to-checkout hook defined in
+ # the push_to_deploy() function in builtin/receive-pack.c.
+ #
+ # Note that the hook will be executed from the repository directory,
+ # not from the working tree, so if you want to perform operations on
+ # the working tree, you will have to adapt your code accordingly, e.g.
+ # by adding "cd .." or using relative paths.
+ 
+ if ! git update-index -q --ignore-submodules --refresh
+ then
+ 	die "Up-to-date check failed"
+ fi
+ 
+ if ! git diff-files --quiet --ignore-submodules --
+ then
+ 	die "Working directory has unstaged changes"
+ fi
+ 
+ # This is a rough translation of:
+ #
+ #   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+ if git cat-file -e HEAD 2>/dev/null
+ then
+ 	head=HEAD
+ else
+ 	head=$(git hash-object -t tree --stdin </dev/null)
+ fi
+ 
+ if ! git diff-index --quiet --cached --ignore-submodules $head --
+ then
+ 	die "Working directory has staged changes"
+ fi
+ 
+ if ! git read-tree -u -m "$commit"
+ then
+ 	die "Could not update working tree to new HEAD"
+ fi
diff -crNb dmenu-5.0/.git/hooks/update.sample Projects/git/dmenu/.git/hooks/update.sample
*** dmenu-5.0/.git/hooks/update.sample	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/hooks/update.sample	2021-11-27 12:52:25.250814088 -0300
***************
*** 0 ****
--- 1,128 ----
+ #!/nix/store/phqa311klldrcbwid1i22dwnpfc9dnma-bash-5.1-p8/bin/bash
+ #
+ # An example hook script to block unannotated tags from entering.
+ # Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+ #
+ # To enable this hook, rename this file to "update".
+ #
+ # Config
+ # ------
+ # hooks.allowunannotated
+ #   This boolean sets whether unannotated tags will be allowed into the
+ #   repository.  By default they won't be.
+ # hooks.allowdeletetag
+ #   This boolean sets whether deleting tags will be allowed in the
+ #   repository.  By default they won't be.
+ # hooks.allowmodifytag
+ #   This boolean sets whether a tag may be modified after creation. By default
+ #   it won't be.
+ # hooks.allowdeletebranch
+ #   This boolean sets whether deleting branches will be allowed in the
+ #   repository.  By default they won't be.
+ # hooks.denycreatebranch
+ #   This boolean sets whether remotely creating branches will be denied
+ #   in the repository.  By default this is allowed.
+ #
+ 
+ # --- Command line
+ refname="$1"
+ oldrev="$2"
+ newrev="$3"
+ 
+ # --- Safety check
+ if [ -z "$GIT_DIR" ]; then
+ 	echo "Don't run this script from the command line." >&2
+ 	echo " (if you want, you could supply GIT_DIR then run" >&2
+ 	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+ 	exit 1
+ fi
+ 
+ if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+ 	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+ 	exit 1
+ fi
+ 
+ # --- Config
+ allowunannotated=$(git config --type=bool hooks.allowunannotated)
+ allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+ denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+ allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+ allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+ 
+ # check for no description
+ projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+ case "$projectdesc" in
+ "Unnamed repository"* | "")
+ 	echo "*** Project description file hasn't been set" >&2
+ 	exit 1
+ 	;;
+ esac
+ 
+ # --- Check types
+ # if $newrev is 0000...0000, it's a commit to delete a ref.
+ zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+ if [ "$newrev" = "$zero" ]; then
+ 	newrev_type=delete
+ else
+ 	newrev_type=$(git cat-file -t $newrev)
+ fi
+ 
+ case "$refname","$newrev_type" in
+ 	refs/tags/*,commit)
+ 		# un-annotated tag
+ 		short_refname=${refname##refs/tags/}
+ 		if [ "$allowunannotated" != "true" ]; then
+ 			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+ 			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/tags/*,delete)
+ 		# delete tag
+ 		if [ "$allowdeletetag" != "true" ]; then
+ 			echo "*** Deleting a tag is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/tags/*,tag)
+ 		# annotated tag
+ 		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+ 		then
+ 			echo "*** Tag '$refname' already exists." >&2
+ 			echo "*** Modifying a tag is not allowed in this repository." >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/heads/*,commit)
+ 		# branch
+ 		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+ 			echo "*** Creating a branch is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/heads/*,delete)
+ 		# delete branch
+ 		if [ "$allowdeletebranch" != "true" ]; then
+ 			echo "*** Deleting a branch is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	refs/remotes/*,commit)
+ 		# tracking branch
+ 		;;
+ 	refs/remotes/*,delete)
+ 		# delete tracking branch
+ 		if [ "$allowdeletebranch" != "true" ]; then
+ 			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+ 			exit 1
+ 		fi
+ 		;;
+ 	*)
+ 		# Anything else (is there anything else?)
+ 		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+ 		exit 1
+ 		;;
+ esac
+ 
+ # --- Finished
+ exit 0
Binary files dmenu-5.0/.git/index and Projects/git/dmenu/.git/index differ
diff -crNb dmenu-5.0/.git/info/exclude Projects/git/dmenu/.git/info/exclude
*** dmenu-5.0/.git/info/exclude	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/info/exclude	2021-11-27 12:52:25.249814087 -0300
***************
*** 0 ****
--- 1,6 ----
+ # git ls-files --others --exclude-from=.git/info/exclude
+ # Lines that start with '#' are comments.
+ # For a project mostly in C, the following would be a good set of
+ # exclude patterns (uncomment them if you want to use them):
+ # *.[oa]
+ # *~
diff -crNb dmenu-5.0/.git/logs/HEAD Projects/git/dmenu/.git/logs/HEAD
*** dmenu-5.0/.git/logs/HEAD	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/logs/HEAD	2021-11-27 12:52:26.792815140 -0300
***************
*** 0 ****
--- 1 ----
+ 0000000000000000000000000000000000000000 7a5355accc8af00036ab9133021b5e321b64080a b4sqss <basqs@tutanota.com> 1638028346 -0300	clone: from https://github.com/NotCreative21/dmenu.git
diff -crNb dmenu-5.0/.git/logs/refs/heads/master Projects/git/dmenu/.git/logs/refs/heads/master
*** dmenu-5.0/.git/logs/refs/heads/master	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/logs/refs/heads/master	2021-11-27 12:52:26.792815140 -0300
***************
*** 0 ****
--- 1 ----
+ 0000000000000000000000000000000000000000 7a5355accc8af00036ab9133021b5e321b64080a b4sqss <basqs@tutanota.com> 1638028346 -0300	clone: from https://github.com/NotCreative21/dmenu.git
diff -crNb dmenu-5.0/.git/logs/refs/remotes/origin/HEAD Projects/git/dmenu/.git/logs/refs/remotes/origin/HEAD
*** dmenu-5.0/.git/logs/refs/remotes/origin/HEAD	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/logs/refs/remotes/origin/HEAD	2021-11-27 12:52:26.791815139 -0300
***************
*** 0 ****
--- 1 ----
+ 0000000000000000000000000000000000000000 7a5355accc8af00036ab9133021b5e321b64080a b4sqss <basqs@tutanota.com> 1638028346 -0300	clone: from https://github.com/NotCreative21/dmenu.git
Binary files dmenu-5.0/.git/objects/pack/pack-3cfbe00ac4df996e69e569b9677b5d836dffe334.idx and Projects/git/dmenu/.git/objects/pack/pack-3cfbe00ac4df996e69e569b9677b5d836dffe334.idx differ
Binary files dmenu-5.0/.git/objects/pack/pack-3cfbe00ac4df996e69e569b9677b5d836dffe334.pack and Projects/git/dmenu/.git/objects/pack/pack-3cfbe00ac4df996e69e569b9677b5d836dffe334.pack differ
diff -crNb dmenu-5.0/.git/packed-refs Projects/git/dmenu/.git/packed-refs
*** dmenu-5.0/.git/packed-refs	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/packed-refs	2021-11-27 12:52:26.790815139 -0300
***************
*** 0 ****
--- 1,2 ----
+ # pack-refs with: peeled fully-peeled sorted 
+ 7a5355accc8af00036ab9133021b5e321b64080a refs/remotes/origin/master
diff -crNb dmenu-5.0/.git/refs/heads/master Projects/git/dmenu/.git/refs/heads/master
*** dmenu-5.0/.git/refs/heads/master	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/refs/heads/master	2021-11-27 12:52:26.792815140 -0300
***************
*** 0 ****
--- 1 ----
+ 7a5355accc8af00036ab9133021b5e321b64080a
diff -crNb dmenu-5.0/.git/refs/remotes/origin/HEAD Projects/git/dmenu/.git/refs/remotes/origin/HEAD
*** dmenu-5.0/.git/refs/remotes/origin/HEAD	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/.git/refs/remotes/origin/HEAD	2021-11-27 12:52:26.791815139 -0300
***************
*** 0 ****
--- 1 ----
+ ref: refs/remotes/origin/master
diff -crNb dmenu-5.0/README Projects/git/dmenu/README
*** dmenu-5.0/README	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/README	2021-11-27 12:52:26.794815141 -0300
***************
*** 22,24 ****
--- 22,33 ----
  Running dmenu
  -------------
  See the man page for details.
+ 
+ 
+ Added Patches
+ -------------
+ center
+ grid
+ gridnav
+ border
+ scroll
diff -crNb dmenu-5.0/config.def.h Projects/git/dmenu/config.def.h
*** dmenu-5.0/config.def.h	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/config.def.h	2021-11-27 12:52:26.794815141 -0300
***************
*** 14,20 ****
  	[SchemeOut] = { "#000000", "#00ffff" },
  };
  /* -l option; if nonzero, dmenu uses vertical list with given number of lines */
! static unsigned int lines      = 0;
  
  /*
   * Characters not considered part of a word while deleting words
--- 14,20 ----
  	[SchemeOut] = { "#000000", "#00ffff" },
  };
  /* -l option; if nonzero, dmenu uses vertical list with given number of lines */
! static unsigned int lines      = 5;
  
  /*
   * Characters not considered part of a word while deleting words
diff -crNb dmenu-5.0/config.h Projects/git/dmenu/config.h
*** dmenu-5.0/config.h	1969-12-31 21:00:00.000000000 -0300
--- Projects/git/dmenu/config.h	2021-11-27 13:01:45.847853228 -0300
***************
*** 0 ****
--- 1,27 ----
+ /* See LICENSE file for copyright and license details. */
+ /* Default settings; can be overriden by command line. */
+ 
+ static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
+ /* -fn option overrides fonts[0]; default X11 font or font set */
+ static const char *fonts[] = {
+ 	"fantasquesansmono nerd font:size=10"
+ };
+ static const char *prompt      = NULL;      /* -p  option; prompt to the left of input field */
+ static const char *colors[SchemeLast][2] = {
+ 	/*     fg         bg       */
+ 	[SchemeNorm] = { "#969896", "#1d1f21" },
+ 	[SchemeSel] = { "#1d1f21", "#f0c674" },
+ 	[SchemeOut] = { "#1d1f21", "#f0c674" },
+ };
+ /* -l option; if nonzero, dmenu uses vertical list with given number of lines */
+ static unsigned int lines      = 10;
+ static unsigned int columns    = 4;
+ 
+ /*
+  * Characters not considered part of a word while deleting words
+  * for example: " /?\"&[]"
+  */
+ static const char worddelimiters[] = " ";
+ 
+ /* Size of the window border */
+ static const unsigned int border_width = 2;
Binary files dmenu-5.0/dmenu and Projects/git/dmenu/dmenu differ
diff -crNb dmenu-5.0/dmenu.1 Projects/git/dmenu/dmenu.1
*** dmenu-5.0/dmenu.1	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/dmenu.1	2021-11-27 12:52:26.796815143 -0300
***************
*** 4,9 ****
--- 4,11 ----
  .SH SYNOPSIS
  .B dmenu
  .RB [ \-bfiv ]
+ .RB [ \-g
+ .IR columns ]
  .RB [ \-l
  .IR lines ]
  .RB [ \-m
***************
*** 47,54 ****
  .B \-i
  dmenu matches menu items case insensitively.
  .TP
  .BI \-l " lines"
! dmenu lists items vertically, with the given number of lines.
  .TP
  .BI \-m " monitor"
  dmenu is displayed on the monitor number supplied. Monitor numbers are starting
--- 49,59 ----
  .B \-i
  dmenu matches menu items case insensitively.
  .TP
+ .BI \-g " columns"
+ dmenu lists items in a grid with the given number of columns.
+ .TP
  .BI \-l " lines"
! dmenu lists items in a grid with the given number of lines.
  .TP
  .BI \-m " monitor"
  dmenu is displayed on the monitor number supplied. Monitor numbers are starting
diff -crNb dmenu-5.0/dmenu.c Projects/git/dmenu/dmenu.c
*** dmenu-5.0/dmenu.c	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/dmenu.c	2021-11-27 12:52:26.796815143 -0300
***************
*** 77,83 ****
  	int i, n;
  
  	if (lines > 0)
! 		n = lines * bh;
  	else
  		n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
  	/* calculate which items will begin the next page and previous page */
--- 77,83 ----
  	int i, n;
  
  	if (lines > 0)
! 		n = lines * columns * bh;
  	else
  		n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
  	/* calculate which items will begin the next page and previous page */
***************
*** 89,94 ****
--- 89,103 ----
  			break;
  }
  
+ static int
+ max_textw(void)
+ {
+ 	int len = 0;
+ 	for (struct item *item = items; item && item->text; item++)
+ 		len = MAX(TEXTW(item->text), len);
+ 	return len;
+ }
+ 
  static void
  cleanup(void)
  {
***************
*** 129,137 ****
  static void
  drawmenu(void)
  {
! 	unsigned int curpos;
  	struct item *item;
  	int x = 0, y = 0, w;
  
  	drw_setscheme(drw, scheme[SchemeNorm]);
  	drw_rect(drw, 0, 0, mw, mh, 1, 1);
--- 138,148 ----
  static void
  drawmenu(void)
  {
!  
!     static int curpos, oldcurlen;
  	struct item *item;
  	int x = 0, y = 0, w;
+     int curlen, rcurlen;
  
  	drw_setscheme(drw, scheme[SchemeNorm]);
  	drw_rect(drw, 0, 0, mw, mh, 1, 1);
***************
*** 142,160 ****
  	}
  	/* draw input field */
  	w = (lines > 0 || !matches) ? mw - x : inputw;
! 	drw_setscheme(drw, scheme[SchemeNorm]);
! 	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
  
- 	curpos = TEXTW(text) - TEXTW(&text[cursor]);
- 	if ((curpos += lrpad / 2 - 1) < w) {
  		drw_setscheme(drw, scheme[SchemeNorm]);
! 		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
! 	}
  
  	if (lines > 0) {
! 		/* draw vertical list */
! 		for (item = curr; item != next; item = item->right)
! 			drawitem(item, x, y += bh, mw - x);
  	} else if (matches) {
  		/* draw horizontal list */
  		x += inputw;
--- 153,186 ----
  	}
  	/* draw input field */
  	w = (lines > 0 || !matches) ? mw - x : inputw;  
!     w -= lrpad / 2;
!     x += lrpad / 2;    
!    
! 
!     rcurlen = drw_fontset_getwidth(drw, text + cursor);
!     curlen = drw_fontset_getwidth(drw, text) - rcurlen;
!     curpos += curlen - oldcurlen;
!     curpos = MIN(w, MAX(0, curpos));
!     curpos = MAX(curpos, w - rcurlen);
!     curpos = MIN(curpos, curlen);
!     oldcurlen = curlen;
  
      drw_setscheme(drw, scheme[SchemeNorm]);
!     drw_text_align(drw, x, 0, curpos, bh, text, cursor, AlignR);
!     drw_text_align(drw, x + curpos, 0, w - curpos, bh, text + cursor, strlen(text) - cursor, AlignL);
!     drw_rect(drw, x + curpos - 1, 2, 2, bh - 4, 1, 0);
! 
  
  	if (lines > 0) {
! 		/* draw grid*/
!         int i = 0;
! 		for (item = curr; item != next; item = item->right, i++)
! 			drawitem(
! 				item,
! 				x + ((i / lines) *  ((mw - x) / columns)),
! 				y + (((i % lines) + 1) * bh),
! 				(mw - x) / columns
! 			);
  	} else if (matches) {
  		/* draw horizontal list */
  		x += inputw;
***************
*** 312,317 ****
--- 338,346 ----
  	KeySym ksym;
  	Status status;
  
+     int i, offscreen = 0;
+     struct item *tmpsel;
+ 
  	len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
  	switch (status) {
  	default: /* XLookupNone, XBufferOverflow */
***************
*** 360,368 ****
--- 389,399 ----
  			                  utf8, utf8, win, CurrentTime);
  			return;
  		case XK_Left:
+ 		case XK_KP_Left:
  			movewordedge(-1);
  			goto draw;
  		case XK_Right:
+ 		case XK_KP_Right:
  			movewordedge(+1);
  			goto draw;
  		case XK_Return:
***************
*** 400,405 ****
--- 431,437 ----
  			insert(buf, len);
  		break;
  	case XK_Delete:
+ 	case XK_KP_Delete:
  		if (text[cursor] == '\0')
  			return;
  		cursor = nextrune(+1);
***************
*** 410,415 ****
--- 442,448 ----
  		insert(NULL, nextrune(-1) - cursor);
  		break;
  	case XK_End:
+ 	case XK_KP_End:
  		if (text[cursor] != '\0') {
  			cursor = strlen(text);
  			break;
***************
*** 429,434 ****
--- 462,468 ----
  		cleanup();
  		exit(1);
  	case XK_Home:
+ 	case XK_KP_Home:
  		if (sel == matches) {
  			cursor = 0;
  			break;
***************
*** 437,442 ****
--- 471,498 ----
  		calcoffsets();
  		break;
  	case XK_Left:
+         if (columns > 1) {
+             if (!sel)
+                 return;
+             tmpsel = sel;
+             for (i = 0; i < lines; i++) {
+                 if (!tmpsel->left || tmpsel->left->right != tmpsel) {
+                     if (offscreen)
+                         break;
+                     return;
+                 }
+                 if (tmpsel == curr) 
+                     offscreen = 1;
+                 tmpsel = tmpsel->left;
+             }
+             sel = tmpsel;
+             if (offscreen) {
+                 curr = prev;
+                 calcoffsets();
+             }
+             break;
+         }
+ 	//case XK_KP_Left:
  		if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
  			cursor = nextrune(-1);
  			break;
***************
*** 445,462 ****
--- 501,521 ----
  			return;
  		/* fallthrough */
  	case XK_Up:
+ 	case XK_KP_Up:
  		if (sel && sel->left && (sel = sel->left)->right == curr) {
  			curr = prev;
  			calcoffsets();
  		}
  		break;
  	case XK_Next:
+ 	case XK_KP_Next:
  		if (!next)
  			return;
  		sel = curr = next;
  		calcoffsets();
  		break;
  	case XK_Prior:
+ 	case XK_KP_Prior:
  		if (!prev)
  			return;
  		sel = curr = prev;
***************
*** 473,478 ****
--- 532,559 ----
  			sel->out = 1;
  		break;
  	case XK_Right:
+         if (columns > 1) {
+             if (!sel)
+                 return;
+             tmpsel = sel;
+             for (i = 0; i < lines; i++) {
+                 if (!tmpsel->right ||  tmpsel->right->left != tmpsel) {
+                     if (offscreen)
+                         break;
+                     return;
+                 }
+                 tmpsel = tmpsel->right;
+                 if (tmpsel == next)
+                     offscreen = 1;
+             }
+             sel = tmpsel;
+             if (offscreen) {
+                 curr = next;
+                 calcoffsets();
+             }
+             break;
+         }  
+ 	//case XK_KP_Right:
  		if (text[cursor] != '\0') {
  			cursor = nextrune(+1);
  			break;
***************
*** 481,486 ****
--- 562,568 ----
  			return;
  		/* fallthrough */
  	case XK_Down:
+ 	case XK_KP_Down:
  		if (sel && sel->right && (sel = sel->right) == next) {
  			curr = next;
  			calcoffsets();
***************
*** 611,616 ****
--- 693,699 ----
  	bh = drw->fonts->h + 2;
  	lines = MAX(lines, 0);
  	mh = (lines + 1) * bh;
+ 	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
  #ifdef XINERAMA
  	i = 0;
  	if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
***************
*** 637,645 ****
  				if (INTERSECT(x, y, 1, 1, info[i]))
  					break;
  
! 		x = info[i].x_org;
! 		y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
! 		mw = info[i].width;
  		XFree(info);
  	} else
  #endif
--- 720,728 ----
  				if (INTERSECT(x, y, 1, 1, info[i]))
  					break;
  
! 		mw = MIN(MAX(max_textw() + promptw, 100), info[i].width);
! 		x = info[i].x_org + ((info[i].width  - mw) / 2);
! 		y = info[i].y_org + ((info[i].height - mh) / 2);
  		XFree(info);
  	} else
  #endif
***************
*** 647,657 ****
  		if (!XGetWindowAttributes(dpy, parentwin, &wa))
  			die("could not get embedding window attributes: 0x%lx",
  			    parentwin);
! 		x = 0;
! 		y = topbar ? 0 : wa.height - mh;
! 		mw = wa.width;
  	}
- 	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
  	inputw = MIN(inputw, mw/3);
  	match();
  
--- 730,739 ----
  		if (!XGetWindowAttributes(dpy, parentwin, &wa))
  			die("could not get embedding window attributes: 0x%lx",
  			    parentwin);
! 		mw = MIN(MAX(max_textw() + promptw, 100), wa.width);
! 		x = (wa.width  - mw) / 2;
! 		y = (wa.height - mh) / 2;
  	}
  	inputw = MIN(inputw, mw/3);
  	match();
  
***************
*** 659,667 ****
  	swa.override_redirect = True;
  	swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
  	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
! 	win = XCreateWindow(dpy, parentwin, x, y, mw, mh, 0,
  	                    CopyFromParent, CopyFromParent, CopyFromParent,
  	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
  	XSetClassHint(dpy, win, &ch);
  
  
--- 741,750 ----
  	swa.override_redirect = True;
  	swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
  	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
! 	win = XCreateWindow(dpy, parentwin, x, y, mw, mh, border_width,
  	                    CopyFromParent, CopyFromParent, CopyFromParent,
  	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
+     XSetWindowBorder(dpy, win, scheme[SchemeSel][ColBg].pixel);
  	XSetClassHint(dpy, win, &ch);
  
  
***************
*** 715,723 ****
  		} else if (i + 1 == argc)
  			usage();
  		/* these options take one argument */
! 		else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
  			lines = atoi(argv[++i]);
! 		else if (!strcmp(argv[i], "-m"))
  			mon = atoi(argv[++i]);
  		else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
  			prompt = argv[++i];
--- 798,810 ----
  		} else if (i + 1 == argc)
  			usage();
  		/* these options take one argument */
! 		else if (!strcmp(argv[i], "-g")) { /* number of lines in grid*/
! 		    columns = atoi(argv[++i]);
!             if (lines == 0) lines = 1;
!         } else if (!strcmp(argv[i], "-l")) { /* number of lines in grid */
  			lines = atoi(argv[++i]);
!             if (columns == 0) columns = 1;
!         } else if (!strcmp(argv[i], "-m"))
              mon = atoi(argv[++i]);
  		else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
  			prompt = argv[++i];
Binary files dmenu-5.0/dmenu.o and Projects/git/dmenu/dmenu.o differ
diff -crNb dmenu-5.0/drw.c Projects/git/dmenu/drw.c
*** dmenu-5.0/drw.c	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/drw.c	2021-11-27 12:52:26.798815144 -0300
***************
*** 379,384 ****
--- 379,554 ----
  	return x + (render ? w : 0);
  }
  
+ int
+ utf8nextchar(const char *str, int len, int i, int inc)
+ {
+     int n;
+ 
+     for (n = i + inc; n + inc >= 0 && n + inc <= len
+       && (str[n] & 0xc0) == 0x80; n += inc)
+         ;
+     return n;
+ }
+ 
+ int
+ drw_text_align(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int textlen, int align)
+ {
+     int ty;
+     unsigned int ew;
+     XftDraw *d = NULL;
+     Fnt *usedfont, *curfont, *nextfont;
+     size_t len;
+     int utf8strlen, utf8charlen, render = x || y || w || h;
+     long utf8codepoint = 0;
+     const char *utf8str;
+     FcCharSet *fccharset;
+     FcPattern *fcpattern;
+     FcPattern *match;
+     XftResult result;
+     int charexists = 0;
+     int i, n;
+ 
+     if (!drw || (render && !drw->scheme) || !text || !drw->fonts || textlen <= 0
+         || (align != AlignL && align != AlignR))
+             return 0;
+     if (!render) {
+         w = ~w;
+     } else {
+         XSetForeground(drw->dpy, drw->gc, drw->scheme[ColBg].pixel);
+         XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
+         d = XftDrawCreate(drw->dpy, drw->drawable,
+                 DefaultVisual(drw->dpy, drw->screen),
+                 DefaultColormap(drw->dpy, drw->screen));
+     }
+ 
+     usedfont = drw->fonts;
+     i = align == AlignL ? 0 : textlen;
+     x = align == AlignL ? x : x + w;
+     while (1) {
+         utf8strlen = 0;
+         nextfont = NULL;
+         /* if (align == AlignL) */
+         utf8str = text + i;
+ 
+ 
+         while ((align == AlignL && i < textlen) || (align == AlignR && i > 0)) {
+             if (align == AlignL) {
+                 utf8charlen = utf8decode(text + i, &utf8codepoint, MIN(textlen - i, UTF_SIZ));
+                 if (!utf8charlen) {
+                     textlen = i;
+                     break;
+                 }
+             } else {
+                 n = utf8nextchar(text, textlen, i, -1);
+                 utf8charlen = utf8decode(text + n, &utf8codepoint, MIN(textlen - n, UTF_SIZ));
+                 if (!utf8charlen) {
+                     textlen -= i;
+                     text += i;
+                     i = 0;
+                     break;
+                 }
+ 
+             }
+             for (curfont = drw->fonts; curfont; curfont = curfont->next) {
+                 charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
+                 if (charexists) {
+                     if (curfont == usedfont) {
+                         utf8strlen += utf8charlen;
+                         i += align == AlignL ? utf8charlen : -utf8charlen;
+                     } else {
+                         nextfont = curfont;
+                     }
+                     break;
+                 }
+             }
+ 
+             if (!charexists || nextfont)
+                 break;
+             else
+                 charexists = 0;
+         }
+ 
+         if (align == AlignR)
+             utf8str = text + i;
+ 
+         if (utf8strlen) {
+             drw_font_getexts(usedfont, utf8str, utf8strlen, &ew, NULL);
+             /* shorten text if necessary */
+             if (align == AlignL) {
+                 for (len = utf8strlen; len && ew > w; ) {
+                     len = utf8nextchar(utf8str, len, len, -1);
+                     drw_font_getexts(usedfont, utf8str, len, &ew, NULL);
+                 }
+             } else {
+                 for (len = utf8strlen; len && ew > w; ) {
+                     n = utf8nextchar(utf8str, len, 0, +1);
+                     utf8str += n;
+                     len -= n;
+                     drw_font_getexts(usedfont, utf8str, len, &ew, NULL);
+                 }
+             }
+ 
+             if (len) {
+                 if (render) {
+                     ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
+                     XftDrawStringUtf8(d, &drw->scheme[ColFg],
+                             usedfont->xfont, align == AlignL ? x : x - ew, ty, (XftChar8 *)utf8str, len);
+                 }
+                 x += align == AlignL ? ew : -ew;
+                 w -= ew;
+             }
+             if (len < utf8strlen)
+                 break;
+         }
+ 
+         if ((align == AlignR && i <= 0) || (align == AlignL && i >= textlen)) {
+             break;
+         } else if (nextfont) {
+             charexists = 0;
+             usedfont = nextfont;
+         } else {
+             /* Regardless of whether or not a fallback font is found, the
+              * character must be drawn. */
+             charexists = 1;
+ 
+             fccharset = FcCharSetCreate();
+             FcCharSetAddChar(fccharset, utf8codepoint);
+ 
+             if (!drw->fonts->pattern) {
+                 /* Refer to the comment in xfont_create for more information. */
+                 die("the first font in the cache must be loaded from a font string.");
+             }
+ 
+             fcpattern = FcPatternDuplicate(drw->fonts->pattern);
+             FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
+             FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
+             
+             FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
+             FcDefaultSubstitute(fcpattern);
+             match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
+ 
+             FcCharSetDestroy(fccharset);
+             FcPatternDestroy(fcpattern);
+ 
+             if (match) {
+                 usedfont = xfont_create(drw, NULL, match);
+                 if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
+                     for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
+                         ; /* NOP */
+                     curfont->next = usedfont;
+                 } else {
+                     xfont_free(usedfont);
+                     usedfont = drw->fonts;
+                 }
+             }
+         }
+     }
+     if (d)
+         XftDrawDestroy(d);
+ 
+     return x;
+ }
+ 
  void
  drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
  {
diff -crNb dmenu-5.0/drw.h Projects/git/dmenu/drw.h
*** dmenu-5.0/drw.h	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/drw.h	2021-11-27 12:52:26.798815144 -0300
***************
*** 13,18 ****
--- 13,19 ----
  } Fnt;
  
  enum { ColFg, ColBg }; /* Clr scheme index */
+ enum { AlignL, AlignR };
  typedef XftColor Clr;
  
  typedef struct {
***************
*** 52,57 ****
--- 53,59 ----
  /* Drawing functions */
  void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
  int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);
+ int drw_text_align(Drw *drw, int x, int y, unsigned int w, unsigned int h, const char *text, int textlen, int align);
  
  /* Map functions */
  void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
Binary files dmenu-5.0/drw.o and Projects/git/dmenu/drw.o differ
Binary files dmenu-5.0/stest and Projects/git/dmenu/stest differ
diff -crNb dmenu-5.0/stest.c Projects/git/dmenu/stest.c
*** dmenu-5.0/stest.c	2020-09-02 13:37:07.000000000 -0300
--- Projects/git/dmenu/stest.c	2021-11-27 12:52:26.799815145 -0300
***************
*** 84,90 ****
  	if (!argc) {
  		/* read list from stdin */
  		while ((n = getline(&line, &linesiz, stdin)) > 0) {
! 			if (n && line[n - 1] == '\n')
  				line[n - 1] = '\0';
  			test(line, line);
  		}
--- 84,90 ----
  	if (!argc) {
  		/* read list from stdin */
  		while ((n = getline(&line, &linesiz, stdin)) > 0) {
! 			if (line[n - 1] == '\n')
  				line[n - 1] = '\0';
  			test(line, line);
  		}
Binary files dmenu-5.0/stest.o and Projects/git/dmenu/stest.o differ
Binary files dmenu-5.0/util.o and Projects/git/dmenu/util.o differ
