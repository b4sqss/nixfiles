// Using tests for convenience. To run tests it's just
// $ zig test {file}
// plus whatever else it needs to run, of course, in this case it
// needs -lc to link libc

const std = @import("std");
const math = std.math;
const c = @cImport({
    @cInclude("stdio.h");
    @cInclude("string.h");
    // I don't even know if zig's stdlib has threads, but it doesn't
    // matter, because posix threads just work(tm)
    @cInclude("pthread.h");
});

// Shit that you don't use just doesn't get included in the final
// binary
const print = std.debug.print;
const expect = std.testing.expect;

test "loops" {
    var i: u32 = 20;

    while (i < 10) : ({
        i += 1;
    }) {
        print("Kek, jk, nobody uses this form of while\n" ++ "Use defer instead\n", .{});
    }

    while (i > 0) {
        defer i -= 1;
        print("Doing shit...\n", .{});
    }

    // defer can do blocks too:
    defer ({
        i = 10;
        while (i > 0) {
            defer i -= 1;
            print("Fuck you\n", .{});
        }
    });

    // Prefer consts because they can be optimized away completely
    const arr1 = [_]u32{ 10, 20, 30 };
    const arr2 = [_]u32{ 40, 20, 60, 20, 30 };
    i = 0;
    for (arr1) |v| {
        // You can't shadow variables, btw, which is shit imo
        // I guess that's an incentive to keep your namespaces clean
        i += v;
    }

    try expect(i == 60);

    // Slices are a pointer + a length, and they aren't immutable
    var slice: []const u32 = arr1[0..2];
    // I can just change it, this kills the rustranny
    slice.ptr = &arr2;
    slice.len = arr2.len;

    i = 0;
    for (slice) |v| {
        i += v;
    }

    try expect(i == 40 + 20 + 60 + 20 + 30);

    // You can label loops, and even return values with break:
    const found = loop: for (arr2) |v| {
        if (v == 22)
            break :loop true;
    } else false;
    // You can also inline loops

    // Zig complains if you don't use what you declare, use _ = * for
    // that. Works with function return types too, in case of c
    // functions.
    _ = found;

    // Everything in the stdlib that allocates memory takes a
    // memory allocator. You'll want to link with libc because at the
    // moment zig doesn't have a general purpose allocator, so you
    // can just use c_allocator
    var arrlist = try std.ArrayList(u8)
        .initCapacity(std.heap.c_allocator, 200);
    defer arrlist.deinit();

    _ = c.sprintf(arrlist.items.ptr, "Pajeet list %s\n", ":)");
    arrlist.items.len = c.strlen(arrlist.items.ptr);
    try arrlist.appendSlice("Good morning sirs!\n");
    print("{s}\n", .{arrlist.items});
}

// Here's structures:
const Point = struct {
    x: i32,
    y: i32,

    // They also double as namespaces
    const center = Point{ 0, 0 };

    // If a function starts with the type or a pointer to the type,
    // you can do x.fn() syntax, but you can also use Point.fn(x).
    fn len(p1: Point, p2: Point) f32 {
        // Language is verbose as fuck with casts...
        const x1 = @intToFloat(f32, p1.x);
        const y1 = @intToFloat(f32, p1.y);
        const x2 = @intToFloat(f32, p2.x);
        const y2 = @intToFloat(f32, p2.y);

        return math.sqrt(math.pow(f32, x1 - x2, @as(f32, 2)) +
            math.pow(f32, y1 - y2, @as(f32, 2)));
    }
};
